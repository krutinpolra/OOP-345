In completing this workshop, I delved into various aspects of C++ programming, particularly focusing on utilizing the Standard Template Library (STL) functions effectively. Here are some key points from my learning:

STL Functions Used:

std::sort(): This function was used to sort the collection of songs based on different criteria such as title, length, and album. The reason for choosing std::sort() is its efficiency and simplicity compared to implementing sorting algorithms manually. It provides a clean and concise way to sort elements in a container.

std::accumulate(): This function was used to calculate the total playtime of all songs in the collection. std::accumulate() is preferred over a manual loop for its readability and conciseness. It sums up the elements in a range efficiently.

std::any_of(): This function was used to check if any song in the collection matches a given artist name. It offers a clear and concise way to perform a logical operation on a range of elements.

Advantages of Using STL Algorithms:

Using STL algorithms provides several advantages over implementing functionality with loops:

Readability:
 STL algorithms offer expressive and self-documenting code, making it easier for other developers to understand the logic behind the operations.

Correctness: 
STL algorithms are well-tested and optimized, reducing the likelihood of errors compared to manually implemented loops.

Efficiency: 
STL algorithms are typically implemented using highly optimized techniques, leading to efficient execution and better performance.

Redesigning the Sorting Function:

To prevent clients from specifying an invalid field name for sorting, I would redesign the function to use an enumeration instead of a string parameter. This way, the compiler can catch any errors at compile time rather than runtime.

enum class SortField { Title, Length, Album };

void SongCollection::sort(SortField field) {
    switch (field) {
        case SortField::Title:
            std::sort(m_song.begin(), m_song.end(), [](const Song& a, const Song& b) {
                return a.m_title < b.m_title;
            });
            break;
        case SortField::Length:
            std::sort(m_song.begin(), m_song.end(), [](const Song& a, const Song& b) {
                return a.m_lengthOfTheSong < b.m_lengthOfTheSong;
            });
            break;
        case SortField::Album:
            std::sort(m_song.begin(), m_song.end(), [](const Song& a, const Song& b) {
                return a.m_album < b.m_album;
            });
            break;
    }
}

I had few problems implementing sort, inCollection, getsong for artist
so i had to revice the lamda expression and the STL containers concepts 
for example: 
return std::any_of(
    m_song.begin(), m_song.end(),
    [&artistName](const Song& song) {
        return song.m_artist == artistName;
    }
);
This function utilizes the std::any_of algorithm from the C++ Standard Library, which checks if any element in a range satisfies a specified condition.

std::any_of(): This function takes three arguments:

m_song.begin() and m_song.end(): These are iterators specifying the range of elements in the m_song vector. It will iterate over each element in this range.
A lambda function: This is the condition to be checked against each element in the range.
Lambda Function:

[&artistName](const Song& song) { ... }: This is a lambda function that takes each Song object in the m_song vector and compares its m_artist member variable with the provided artistName.
[&artistName]: This captures artistName by reference, allowing the lambda function to access it.
(const Song& song): This specifies the parameter type for the lambda function, which is a const reference to a Song object.
{ return song.m_artist == artistName; }: This is the body of the lambda function. It compares the m_artist of each Song object with the artistName provided as an argument. If the m_artist matches the artistName, the function returns true; otherwise, it returns false.
Return Value:

std::any_of returns true if the condition specified by the lambda function is true for at least one element in the range. Otherwise, it returns false.
