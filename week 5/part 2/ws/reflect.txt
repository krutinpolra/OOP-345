//Name:     Krutin Bharatbhai Polra
//studentID:135416220
//email:    kbpolra@myseneca.ca
//Date:     25th february 2024
//Course:   OOP345 NAA
// I have done all the coding by myself and only copied the code 
// that my professor provided to complete my workshops and assignments.

Functor vs. Lambda Expression:
In the provided modules, both functors and lambda expressions are utilized. For instance, in the SpellChecker class, the operator() is overloaded, making it a functor that can be called like a function. On the other hand, lambda expressions could be used for similar functionality in some cases, providing a more concise syntax for defining small function objects inline. I struggled with a function a little bit becasue the concept wasn't very clear i also struggled with lamda expression too. I had to revise all the concepts and i had to watch the lacture first of all i was confused that why should we use lamda expression and functor 
so I learned that 

Lambda Expressions:
Lambda expressions are anonymous functions that can be defined inline within code. They offer a concise syntax for creating small, one-off function objects. Lambda expressions are particularly useful in situations where a short piece of code needs to be passed as an argument to algorithms, functions, or constructors. Common use cases for lambda expressions include:

STL Algorithms: Lambda expressions are frequently used with Standard Template Library (STL) algorithms such as std::sort, std::find_if, std::transform, etc., where custom behavior is required.
Callbacks: When working with libraries or frameworks that expect callbacks, lambda expressions provide a convenient way to define these callbacks inline without the need to declare separate named functions.
Event Handlers: In GUI programming, lambda expressions are commonly used for defining event handlers for user interface elements.
Concurrency: In multithreaded programming, lambda expressions can be used with thread creation functions or in parallel algorithms to define concurrent tasks.

aacording to code
In the SpellChecker class, the operator() is overloaded to perform spell checking on a given text string. This operator is essentially a lambda expression defined within the class. It takes a string reference as its argument and iterates through the text to replace misspelled words with their correct counterparts. Lambda expressions are particularly useful here because they allow for the definition of small, inline functions directly within the operator() implementation. This approach results in concise and readable code.

Functors:
Functors, or function objects, are objects that can be called as if they were functions. They are defined by overloading the operator() within a class. Functors provide more flexibility and control compared to lambda expressions, as they can maintain state between calls. Functors are useful in situations where more complex behavior or customization is required. 

according to code:
The SpellChecker class itself can be considered a functor. It encapsulates the spell checking behavior within its overloaded operator() method, effectively allowing instances of SpellChecker to be invoked like functions. When an instance of SpellChecker is called with a string argument, it performs spell checking on that string. Functors are advantageous in this context because they can maintain state between calls, such as keeping track of statistics on misspelled words, which is demonstrated in the SpellChecker class by tracking the number of replacements for each misspelled word.


Knowing when to use each depends on the complexity and reusability of the functionality needed. Functors are preferred when maintaining state or requiring more complex behavior, while lambda expressions offer brevity and are suitable for one-off operations.

Handling Exceptions in SpellChecker Constructor:
The constructor for SpellChecker generates an exception when the file specified does not exist. To handle this without exceptions, one could return an error code or set an error flag within the class. Similarly, on the client side, one would need to check for errors after object creation and handle them appropriately, such as displaying an error message. This approach ensures graceful error handling without abruptly terminating the program flow.

Redesigning Movie and Book Classes:
The classes Movie and Book exhibit similarities in functionality, particularly in parsing and storing data from a string. To avoid duplicating this logic, one could refactor common functionality into a base class (e.g., Media) and derive Movie and Book classes from it. This restructuring promotes code reuse and improves maintainability by centralizing shared logic.

i also learned some of the new functions which can be helpfull in the file handling 

isspace():

Used in the eliminateSpace() function to check for whitespace characters.
It's employed to trim leading and trailing spaces from strings before storing them in Book, Movie, and SpellChecker objects.

string::npos:

string::npos represents the maximum possible value for the size type of a string. It is used as a return value by various string member functions when they fail to find what they are searching for.
In the code, it's primarily used in conjunction with the find() function to check if a particular substring is found within another string. If find() does not find the substring, it returns string::npos.

find():

Used to find the position of a substring within a string.
In the code, find() is employed in various places to locate specific delimiters or substrings, allowing for the parsing of input strings into meaningful components.

replace():

Used to replace occurrences of a substring within a string with another substring.
In the SpellChecker class, replace() is utilized within the operator() method to replace misspelled words with their correct counterparts.

to_string():

Converts numerical values to their string representations.
In the Collection class, to_string() is not explicitly used in the provided code, but it could be used to convert numerical values to strings if needed, for example, when constructing error messages or logging information.

out_of_range:

Represents an exception thrown when an attempt is made to access an element outside the bounds of a container.
In the Collection class, an instance of out_of_range exception is thrown when an attempt is made to access an element at an index that exceeds the size of the collection.